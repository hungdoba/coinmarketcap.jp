import {
  createAsyncThunk,
  createSlice,
  PayloadAction,
  Slice,
  SliceCaseReducers,
} from '@reduxjs/toolkit';
import { cacheWithExpiry, retrieveCache, toCamelCase } from '../common/helpers';
import { RootState } from '../app/store';
import { Coin, CoinListState, CoinQueryParams } from '../models';

interface Reducers extends SliceCaseReducers<CoinListState> {
  setCoinQueryParams: (
    state: CoinListState,
    action: PayloadAction<CoinQueryParams>
  ) => void;
  addCoinListTableColumn: (
    state: CoinListState,
    action: PayloadAction<keyof Coin>
  ) => void;
  removeCoinListTableColumn: (
    state: CoinListState,
    action: PayloadAction<keyof Coin>
  ) => void;
  clearCoinListValue: (state: CoinListState) => void;
}

const initialState: CoinListState = {
  value: [],
  status: 'IDLE',
  coinQueryParams: {
    sortingKey: 'market_cap',
    sortingOrder: 'desc',
    page: 1,
    perPage: 20,
    category: '',
  },
  coinListTableColumns: retrieveCache('coinListTableColumns') || [
    'priceChangePercentage24HInCurrency',
    'priceChangePercentage7DInCurrency',
    'marketCap',
    'totalVolume',
    'circulatingSupply',
    'sparklineIn7D',
  ],
  hasMore: true,
};

interface Params {
  coinQueryParams: CoinQueryParams;
  append: boolean;
}

export const fetchCoinList = createAsyncThunk(
  'coinList',
  async (params: Params) => {
    const url = `${process.env.REACT_APP_BACKEND_URL}/coins?sortingKey=${params.coinQueryParams.sortingKey}&sortingOrder=${params.coinQueryParams.sortingOrder}&page=${params.coinQueryParams.page}&perPage=${params.coinQueryParams.perPage}&sparkline=true&category=${params.coinQueryParams.category}`;

    const response = await fetch(url);

    if (!response.ok) {
      throw new Error('Failed to fetch coin list');
    }

    const jsonData = await response.json();

    const normalizedResponse = toCamelCase(jsonData);

    return { data: normalizedResponse, append: params.append } as {
      data: Coin[];
      append: boolean;
    };
  }
);

export const selectCoinList: (state: RootState) => CoinListState = (
  state: RootState
) => state.coinList;

export const coinListSlice: Slice<CoinListState, Reducers, 'coinList'> =
  createSlice({
    name: 'coinList',
    initialState,
    // The `reducers` field lets us define reducers and generate associated actions
    reducers: {
      setCoinQueryParams: (
        state: CoinListState,
        action: PayloadAction<CoinQueryParams>
      ) => {
        state.coinQueryParams = action.payload;
      },
      addCoinListTableColumn: (
        state: CoinListState,
        action: PayloadAction<keyof Coin>
      ) => {
        state.coinListTableColumns.push(action.payload);
      },
      removeCoinListTableColumn: (
        state: CoinListState,
        action: PayloadAction<keyof Coin>
      ) => {
        state.coinListTableColumns = state.coinListTableColumns.filter(
          (item: keyof Coin) => {
            return item !== action.payload;
          }
        );
      },
      clearCoinListValue: (state: CoinListState) => {
        state.value = state.value.slice(0, state.coinQueryParams.perPage);
        state.coinQueryParams.page = 1;
        state.hasMore = true;
      },
    },
    // The `extraReducers` field lets the slice handle actions defined elsewhere,
    // including actions generated by createAsyncThunk or in other slices.
    extraReducers: (builder) => {
      builder
        .addCase(fetchCoinList.pending, (state, action) => {
          state.status = action.meta.arg.append ? 'LOADING MORE' : 'LOADING';
        })
        .addCase(fetchCoinList.fulfilled, (state, action) => {
          state.status = 'IDLE';
          if (action.payload.data && Array.isArray(action.payload.data)) {
            state.value = action.payload.append
              ? [...state.value, ...action.payload.data]
              : action.payload.data;
            action.payload.data.length === 0
              ? (state.hasMore = false)
              : (state.hasMore = true);
          }
        })
        .addCase(fetchCoinList.rejected, (state, action) => {
          state.status = 'FAILED';
          state.error = action.error.message;
        });
    },
  });

export const {
  setCoinQueryParams,
  addCoinListTableColumn,
  removeCoinListTableColumn,
  clearCoinListValue,
} = coinListSlice.actions;

export default coinListSlice.reducer;
